"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var AutodiscoverErrorCode_1 = require("../../Enumerations/AutodiscoverErrorCode");
var AutodiscoverResponseException_1 = require("../../Exceptions/AutodiscoverResponseException");
var EwsLogging_1 = require("../../Core/EwsLogging");
var EwsServiceXmlWriter_1 = require("../../Core/EwsServiceXmlWriter");
var EwsUtilities_1 = require("../../Core/EwsUtilities");
var EwsXmlReader_1 = require("../../Core/EwsXmlReader");
var ExchangeServerInfo_1 = require("../../Core/ExchangeServerInfo");
var ExchangeVersion_1 = require("../../Enumerations/ExchangeVersion");
var Promise_1 = require("../../Promise");
var ServiceResponse_1 = require("../../Core/Responses/ServiceResponse");
var ServiceResponseException_1 = require("../../Exceptions/ServiceResponseException");
var SoapFaultDetails_1 = require("../../Misc/SoapFaultDetails");
var XmlElementNames_1 = require("../../Core/XmlElementNames");
var XmlNamespace_1 = require("../../Enumerations/XmlNamespace");
/**
 * @internal Represents the base class for all requested made to the Autodiscover service.
 */
var AutodiscoverRequest = /** @class */ (function () {
    /**
     * @internal Initializes a new instance of the **AutodiscoverRequest** class.
     *
     * @param   {AutodiscoverService}   service   Autodiscover service associated with this request.
     * @param   {Uri}                   url       URL of Autodiscover service.
     */
    function AutodiscoverRequest(service, url) {
        this.url = null;
        this.service = service;
        this.url = url;
    }
    Object.defineProperty(AutodiscoverRequest.prototype, "Service", {
        /**
         * @internal Gets the URL.
         */
        get: function () {
            return this.service;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutodiscoverRequest.prototype, "Url", {
        /**
         * @internal Gets the service.
         */
        get: function () {
            return this.url;
        },
        enumerable: true,
        configurable: true
    });
    AutodiscoverRequest.prototype.CreateRedirectionResponse = function (httpWebResponse /*IEwsHttpWebResponse*/) {
        //string location = httpWebResponse.Headers[System.Net.HttpResponseHeader.Location];
        //    if (!string.IsNullOrEmpty(location)) {
        //        try {
        //            Uri redirectionUri = new Uri(this.Url, location);
        //            if ((redirectionUri.Scheme == Uri.UriSchemeHttp) || (redirectionUri.Scheme == Uri.UriSchemeHttps)) {
        //                AutodiscoverResponse response = this.CreateServiceResponse();
        //                response.ErrorCode = AutodiscoverErrorCode.RedirectUrl;
        //                response.RedirectionUrl = redirectionUri;
        //                return response;
        //            }
        //            this.Service.TraceMessage(
        //                TraceFlags.AutodiscoverConfiguration,
        //                string.Format("Invalid redirection URL '{0}' returned by Autodiscover service.", redirectionUri));
        //        }
        //        catch (UriFormatException) {
        //            this.Service.TraceMessage(
        //                TraceFlags.AutodiscoverConfiguration,
        //                string.Format("Invalid redirection location '{0}' returned by Autodiscover service.", location));
        //        }
        //    }
        //    else {
        //        this.Service.TraceMessage(
        //            TraceFlags.AutodiscoverConfiguration,
        //            "Redirection response returned by Autodiscover service without redirection location.");
        //    }
        return null;
    };
    AutodiscoverRequest.prototype.GetResponseStream = function (response /*IEwsHttpWebResponse*/) {
        //string contentEncoding = response.ContentEncoding;
        //Stream responseStream = response.GetResponseStream();
        //if (contentEncoding.ToLowerInvariant().Contains("gzip")) {
        //    return new GZipStream(responseStream, CompressionMode.Decompress);
        //}
        //else if (contentEncoding.ToLowerInvariant().Contains("deflate")) {
        //    return new DeflateStream(responseStream, CompressionMode.Decompress);
        //}
        //else {
        //    return responseStream;
        //}
    };
    /**
     * Executes this instance.
     *
     * @return  {Promise<AutodiscoverResponse>}      [description]
     */
    AutodiscoverRequest.prototype.InternalExecute = function () {
        return __awaiter(this, void 0, Promise_1.Promise, function () {
            var writer, cc, xhrOptions, xhrResponse, ewsXmlReader, responseObject, response, resperr_1, exception;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.Validate();
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        writer = new EwsServiceXmlWriter_1.EwsServiceXmlWriter(this.service);
                        this.WriteSoapRequest(this.url, writer);
                        if (!this.service)
                            throw new Error("Missing Service");
                        cc = writer.GetXML();
                        xhrOptions = {
                            type: "POST",
                            data: cc,
                            url: this.url.ToString(),
                            headers: { "Content-Type": "text/xml" },
                        };
                        //If not set, credentials might come from custom XHRApi
                        if (this.service.Credentials) {
                            this.service.Credentials.PrepareWebRequest(xhrOptions);
                        }
                        EwsLogging_1.EwsLogging.DebugLog("sending ews request");
                        EwsLogging_1.EwsLogging.DebugLog(__assign(__assign({}, xhrOptions), { headers: __assign(__assign({}, xhrOptions.headers), { Authorization: "REDACTED" }) }), true);
                        return [4 /*yield*/, this.service.XHRApi.xhr(xhrOptions)];
                    case 2:
                        xhrResponse = _a.sent();
                        ewsXmlReader = new EwsXmlReader_1.EwsXmlReader(xhrResponse.responseText || xhrResponse.response);
                        responseObject = ewsXmlReader.JsObject;
                        EwsLogging_1.EwsLogging.DebugLog(responseObject, true);
                        if (xhrResponse.status == 200) {
                            EwsLogging_1.EwsLogging.DebugLog(xhrResponse, true);
                            this.ReadSoapHeader(responseObject[XmlElementNames_1.XmlElementNames.SOAPHeaderElementName]);
                            response = this.ReadSoapBody(responseObject);
                            if (response.ErrorCode == AutodiscoverErrorCode_1.AutodiscoverErrorCode.NoError) {
                                //todo: passon to successDelegate
                                //return response;
                            }
                            else {
                                throw new AutodiscoverResponseException_1.AutodiscoverResponseException(response.ErrorCode, response.ErrorMessage);
                            }
                        }
                        else {
                            EwsLogging_1.EwsLogging.Log("status !== 200", true, true);
                            EwsLogging_1.EwsLogging.Log(xhrResponse.response, true, true);
                            EwsLogging_1.EwsLogging.Log(ewsXmlReader, true, true);
                        }
                        return [2 /*return*/, response || xhrResponse.responseText || xhrResponse.response];
                    case 3:
                        resperr_1 = _a.sent();
                        exception = void 0;
                        try {
                            this.ProcessWebException(resperr_1);
                        }
                        catch (exc) {
                            exception = exc;
                        }
                        throw (exception || resperr_1.responseText || resperr_1.response);
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @internal Determines whether response is a redirection.
     *
     * @param   {XMLHttpRequest}    httpWebResponse   The HTTP web response.
     * @return  {boolean}           True if redirection response.
     */
    AutodiscoverRequest.IsRedirectionResponse = function (httpWebResponse) {
        return (httpWebResponse.status == 302 /* Redirect */) ||
            (httpWebResponse.status == 301 /* Moved */) ||
            (httpWebResponse.status == 307 /* RedirectKeepVerb */) ||
            (httpWebResponse.status == 303 /* RedirectMethod */);
    };
    /**
     * @internal Loads response from XML.
     *
     * @param   {any} responseObject  Json Object converted from XML.
     */
    AutodiscoverRequest.prototype.LoadFromXmlJsObject = function (jsObject) {
        var elementName = this.GetResponseXmlElementName();
        var responseObject = jsObject[elementName];
        var response = this.CreateServiceResponse();
        response.LoadFromXmlJsObject(responseObject[XmlElementNames_1.XmlElementNames.Response]);
        return response;
    };
    /**
     * Processes the web exception.
     *
     * @param   {XMLHttpRequest}   webException   The web exception.
     */
    AutodiscoverRequest.prototype.ProcessWebException = function (webException) {
        if (webException.response) {
            //IEwsHttpWebResponse httpWebResponse = this.Service.HttpWebRequestFactory.CreateExceptionResponse(webException);
            var soapFaultDetails = null;
            if (webException.status == 500 /* InternalServerError */) {
                // If tracing is enabled, we read the entire response into a MemoryStream so that we
                // can pass it along to the ITraceListener. Then we parse the response from the
                // MemoryStream.
                //if (this.Service.IsTraceEnabledFor(TraceFlags.AutodiscoverRequest)) {
                //using(MemoryStream memoryStream = new MemoryStream())
                //{
                //    using(Stream serviceResponseStream = AutodiscoverRequest.GetResponseStream(httpWebResponse))
                //    {
                //        // Copy response to in-memory stream and reset position to start.
                //        EwsUtilities.CopyStream(serviceResponseStream, memoryStream);
                //        memoryStream.Position = 0;
                //    }
                //todo implement tracing to base class.
                //this.Service.TraceResponse(httpWebResponse, memoryStream);
                //var reader = new EwsXmlReader(webException.responseText);
                //soapFaultDetails = this.ReadSoapFault(reader);
                //}
                //}
                //else {
                //    using(Stream stream = AutodiscoverRequest.GetResponseStream(httpWebResponse))
                //    {
                //        EwsXmlReader reader = new EwsXmlReader(stream);
                //        soapFaultDetails = this.ReadSoapFault(reader);
                //    }
                //}
                var reader = new EwsXmlReader_1.EwsXmlReader(webException.responseText || webException.response);
                soapFaultDetails = this.ReadSoapFault(reader.JsObject);
                if (soapFaultDetails) {
                    //todo: implement soap fault error throw
                    throw new ServiceResponseException_1.ServiceResponseException(new ServiceResponse_1.ServiceResponse(soapFaultDetails));
                }
            }
            else {
                //todo: fix this
                this.Service.ProcessHttpErrorResponse(webException, webException);
            }
        }
    };
    /**
     * @internal Read SOAP body.
     *
     * @param   {object}   jsObject   EwsXmlReader
     * @returns {AutodiscoverResponse}  AutodiscoverResponse
     */
    AutodiscoverRequest.prototype.ReadSoapBody = function (jsObject) {
        var responses = this.LoadFromXmlJsObject(jsObject[XmlElementNames_1.XmlElementNames.SOAPBodyElementName]);
        return responses;
    };
    /**
     * Reads the SOAP fault.
     *
     * @param   {any}   jsObject   The reader.
     * @return  {SoapFaultDetails}  SOAP fault details.
     */
    AutodiscoverRequest.prototype.ReadSoapFault = function (jsObject) {
        var soapFaultDetails = undefined;
        if (jsObject && jsObject[XmlElementNames_1.XmlElementNames.SOAPBodyElementName]) {
            var obj = jsObject[XmlElementNames_1.XmlElementNames.SOAPBodyElementName];
            if (obj[XmlElementNames_1.XmlElementNames.SOAPFaultElementName])
                soapFaultDetails = SoapFaultDetails_1.SoapFaultDetails.Parse(obj[XmlElementNames_1.XmlElementNames.SOAPFaultElementName]);
        }
        return soapFaultDetails;
        //skipped xml section, using Json only.
        //////try {
        //////    // WCF may not generate an XML declaration.
        //////    reader.Read();
        //////    //if (reader.NodeType == Node.  System.Xml.XmlNodeType.XmlDeclaration) {
        //////    //    reader.Read();
        //////    //}
        //////    if (reader.LocalName != XmlElementNames.SOAPEnvelopeElementName) {
        //////        return soapFaultDetails;
        //////    }
        //////    // Get the namespace URI from the envelope element and use it for the rest of the parsing.
        //////    // If it's not 1.1 or 1.2, we can't continue.
        //////    var soapNamespace: XmlNamespace = EwsUtilities.GetNamespaceFromUri(reader.NamespaceUri);
        //////    if (soapNamespace == XmlNamespace.NotSpecified) {
        //////        return soapFaultDetails;
        //////    }
        //////    reader.Read();
        //////    // Skip SOAP header.
        //////    if (reader.IsElement(soapNamespace, XmlElementNames.SOAPHeaderElementName)) {
        //////        do {
        //////            reader.Read();
        //////        }
        //////        while (reader.HasRecursiveParent(XmlElementNames.SOAPHeaderElementName));
        //////        // Queue up the next read
        //////        //reader.Read(); - no need with nodeiterator/treewalker as the node is already a body Node
        //////    }
        //////    // Parse the fault element contained within the SOAP body.
        //////    if (reader.IsElement(soapNamespace, XmlElementNames.SOAPBodyElementName)) {
        //////        do {
        //////            reader.Read();
        //////            // Parse Fault element
        //////            if (reader.IsElement(soapNamespace, XmlElementNames.SOAPFaultElementName)) {
        //////                soapFaultDetails = SoapFaultDetails.Parse(reader, soapNamespace);
        //////            }
        //////        }
        //////        while (reader.HasRecursiveParent(XmlElementNames.SOAPBodyElementName));
        //////    }
        //////}
        //////catch (XmlException) {
        //////    // If response doesn't contain a valid SOAP fault, just ignore exception and
        //////    // return null for SOAP fault details.
        //////}
        //////return soapFaultDetails;
    };
    /**
     * @internal Read SOAP headers.
     *
     * @param   {object}   reader   EwsXmlReader
     */
    AutodiscoverRequest.prototype.ReadSoapHeader = function (jsobject) {
        this.service.ServerInfo = ExchangeServerInfo_1.ExchangeServerInfo.Parse(jsobject[XmlElementNames_1.XmlElementNames.ServerVersionInfo]);
    };
    /**
     * @internal Validates the request.
     */
    AutodiscoverRequest.prototype.Validate = function () {
        this.Service.Validate();
    };
    /**
     * @internal Writes XML body.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    AutodiscoverRequest.prototype.WriteBodyToXml = function (writer) {
        writer.WriteStartElement(XmlNamespace_1.XmlNamespace.Autodiscover, this.GetRequestXmlElementName());
        this.WriteAttributesToXml(writer);
        this.WriteElementsToXml(writer);
        writer.WriteEndElement(); // m:this.GetXmlElementName()
    };
    /**
     * @internal Write extra headers.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer
     */
    AutodiscoverRequest.prototype.WriteExtraCustomSoapHeadersToXml = function (writer) { };
    /**
     * @internal Writes the autodiscover SOAP request.
     *
     * @param   {Uri}                   requestUrl   Request URL.
     * @param   {EwsServiceXmlWriter}   writer       The writer.
     */
    AutodiscoverRequest.prototype.WriteSoapRequest = function (requestUrl, writer) {
        writer.WriteStartElement(XmlNamespace_1.XmlNamespace.Soap, XmlElementNames_1.XmlElementNames.SOAPEnvelopeElementName);
        writer.WriteAttributeValue("xmlns", EwsUtilities_1.EwsUtilities.AutodiscoverSoapNamespacePrefix, EwsUtilities_1.EwsUtilities.AutodiscoverSoapNamespace);
        writer.WriteAttributeValue("xmlns", EwsUtilities_1.EwsUtilities.WSAddressingNamespacePrefix, EwsUtilities_1.EwsUtilities.WSAddressingNamespace);
        writer.WriteAttributeValue("xmlns", EwsUtilities_1.EwsUtilities.EwsXmlSchemaInstanceNamespacePrefix, EwsUtilities_1.EwsUtilities.EwsXmlSchemaInstanceNamespace);
        if (writer.RequireWSSecurityUtilityNamespace) {
            writer.WriteAttributeValue("xmlns", EwsUtilities_1.EwsUtilities.WSSecurityUtilityNamespacePrefix, EwsUtilities_1.EwsUtilities.WSSecurityUtilityNamespace);
        }
        writer.WriteStartElement(XmlNamespace_1.XmlNamespace.Soap, XmlElementNames_1.XmlElementNames.SOAPHeaderElementName);
        if (this.Service.Credentials != null) {
            this.Service.Credentials.EmitExtraSoapHeaderNamespaceAliases(writer);
        }
        writer.WriteElementValue(XmlNamespace_1.XmlNamespace.Autodiscover, XmlElementNames_1.XmlElementNames.RequestedServerVersion, ExchangeVersion_1.ExchangeVersion[this.Service.RequestedServerVersion]);
        writer.WriteElementValue(XmlNamespace_1.XmlNamespace.WSAddressing, XmlElementNames_1.XmlElementNames.Action, this.GetWsAddressingActionName());
        writer.WriteElementValue(XmlNamespace_1.XmlNamespace.WSAddressing, XmlElementNames_1.XmlElementNames.To, requestUrl.AbsoluteUri);
        this.WriteExtraCustomSoapHeadersToXml(writer);
        //if (this.Service.Credentials != null) {
        //    this.Service.Credentials.SerializeWSSecurityHeaders(writer.InternalWriter);
        //}
        //this.Service.DoOnSerializeCustomSoapHeaders(writer.InternalWriter);
        writer.WriteEndElement(); // soap:Header
        writer.WriteStartElement(XmlNamespace_1.XmlNamespace.Soap, XmlElementNames_1.XmlElementNames.SOAPBodyElementName);
        this.WriteBodyToXml(writer);
        writer.WriteEndElement(); // soap:Body
        writer.WriteEndElement(); // soap:Envelope
        writer.Flush();
    };
    return AutodiscoverRequest;
}());
exports.AutodiscoverRequest = AutodiscoverRequest;
//# sourceMappingURL=AutodiscoverRequest.js.map