"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var ArgumentException_1 = require("../Exceptions/ArgumentException");
var AutodiscoverDnsClient_1 = require("./AutodiscoverDnsClient");
var AutodiscoverEndpoints_1 = require("../Enumerations/AutodiscoverEndpoints");
var AutodiscoverErrorCode_1 = require("../Enumerations/AutodiscoverErrorCode");
var AutodiscoverLocalException_1 = require("../Exceptions/AutodiscoverLocalException");
var AutodiscoverRequest_1 = require("./Requests/AutodiscoverRequest");
var EwsLogging_1 = require("../Core/EwsLogging");
var EwsUtilities_1 = require("../Core/EwsUtilities");
var ExchangeVersion_1 = require("../Enumerations/ExchangeVersion");
var GetDomainSettingsRequest_1 = require("./Requests/GetDomainSettingsRequest");
var GetUserSettingsRequest_1 = require("./Requests/GetUserSettingsRequest");
var OAuthCredentials_1 = require("../Credentials/OAuthCredentials");
var PartnerTokenCredentials_1 = require("../Credentials/PartnerTokenCredentials");
var Promise_1 = require("../Promise");
var ServiceValidationException_1 = require("../Exceptions/ServiceValidationException");
var ServiceVersionException_1 = require("../Exceptions/ServiceVersionException");
var ExtensionMethods_1 = require("../ExtensionMethods");
var Strings_1 = require("../Strings");
var TraceFlags_1 = require("../Enumerations/TraceFlags");
var Uri_1 = require("../Uri");
var WindowsLiveCredentials_1 = require("../Credentials/WindowsLiveCredentials");
var X509CertificateCredentials_1 = require("../Credentials/X509CertificateCredentials");
var ExchangeServiceBase_1 = require("../Core/ExchangeServiceBase");
/**
 * Represents a binding to the Exchange Autodiscover Service.
 * @sealed
 */
var AutodiscoverService = /** @class */ (function (_super) {
    __extends(AutodiscoverService, _super);
    function AutodiscoverService(domainUrlServiceOrVersion, domainOrVersion, version) {
        if (domainUrlServiceOrVersion === void 0) { domainUrlServiceOrVersion = null; }
        if (domainOrVersion === void 0) { domainOrVersion = null; }
        if (version === void 0) { version = ExchangeVersion_1.ExchangeVersion.Exchange2010; }
        var _this = this;
        var argsLength = arguments.length;
        if (argsLength > 3) {
            throw new Error("AutodiscoverService.ts - ctor with " + argsLength + " parameters, invalid number of arguments, check documentation and try again.");
        }
        var service = null;
        var domain = null;
        var url = null;
        var requestedServerVersion = version;
        var hasService = false;
        var hasVersion = false;
        if (argsLength >= 1) {
            if (domainUrlServiceOrVersion instanceof Uri_1.Uri) {
                url = domainUrlServiceOrVersion;
            }
            else if (domainUrlServiceOrVersion instanceof ExchangeServiceBase_1.ExchangeServiceBase) {
                service = domainUrlServiceOrVersion;
                hasService = true;
            }
            else if (typeof domainUrlServiceOrVersion === 'string') {
                domain = domainUrlServiceOrVersion;
            }
            else if (typeof domainUrlServiceOrVersion === 'number') {
                requestedServerVersion = domainUrlServiceOrVersion;
                hasVersion = true;
            }
        }
        if (argsLength >= 2) {
            if (typeof domainOrVersion === 'string') {
                if (!(domainUrlServiceOrVersion instanceof Uri_1.Uri)) {
                    throw new Error("AutodiscoverService.ts - ctor with " + argsLength + " parameters - incorrect uses of parameter at 1st position, it must be Uri when using string at 2nd place");
                }
                domain = domainOrVersion;
            }
            else if (typeof domainOrVersion === 'number') {
                requestedServerVersion = domainOrVersion;
            }
        }
        if (ExtensionMethods_1.hasValue(service)) {
            _this = _super.call(this, service, requestedServerVersion) || this;
        }
        else {
            EwsUtilities_1.EwsUtilities.ValidateDomainNameAllowNull(domain, "domain");
            _this = _super.call(this, requestedServerVersion) || this;
            _this.url = url;
            _this.domain = domain;
        }
        _this.dnsClient = new AutodiscoverDnsClient_1.AutodiscoverDnsClient(_this);
        _this.isExternal = true;
        _this.enableScpLookup = false; // ref: no SCP for nodejs yet.
        return _this;
    }
    Object.defineProperty(AutodiscoverService, "Office365AutodiscoverUrl", {
        /**
         *  Set Autodiscover hard coded url for Office 365, useful in GCC and O365 in China. This is also helpful if O365 need changing url for some reason (beta testing, transition to different url), no need to update lib
         *
         * @static
         * @type {string}
         */
        get: function () {
            return this.o365AutodiscoverUrl;
        },
        set: function (value) {
            this.o365AutodiscoverUrl = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutodiscoverService, "Office365AutodiscoverRedirectHeader", {
        /**
         *  Set Autodiscover hard coded check for header when it is auto redirected (skip 302 and follow the redirect in lib, likely browsers)
         *
         * @static
         * @type {string}
         */
        get: function () {
            return this.o365AutodiscoverRedirectHeader;
        },
        set: function (value) {
            this.o365AutodiscoverRedirectHeader = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutodiscoverService, "Office365AutodiscoverRedirectHeaderValue", {
        /**
         *  Set Autodiscover hard coded check for header value when it is auto redirected (skip 302 and follow the redirect in lib, likely browsers)
         *
         * @static
         * @type {string}
         */
        get: function () {
            return this.o365AutodiscoverRedirectHeaderValue;
        },
        set: function (value) {
            this.o365AutodiscoverRedirectHeaderValue = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutodiscoverService.prototype, "Domain", {
        //#endregion
        //#region Properties | Getter/Setter
        get: function () {
            return this.domain;
        },
        set: function (value) {
            this.domain = value;
            if (value)
                this.url = undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutodiscoverService.prototype, "Url", {
        get: function () {
            return this.url;
        },
        set: function (value) {
            this.url = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutodiscoverService.prototype, "IsExternal", {
        get: function () {
            return this.isExternal;
        },
        set: function (value) {
            this.isExternal = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutodiscoverService.prototype, "RedirectionUrlValidationCallback", {
        get: function () {
            return this.redirectionUrlValidationCallback;
        },
        set: function (value) {
            this.redirectionUrlValidationCallback = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutodiscoverService.prototype, "DnsServerAddress", {
        get: function () {
            return this.dnsServerAddress;
        },
        set: function (value) {
            this.dnsServerAddress = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutodiscoverService.prototype, "EnableScpLookup", {
        get: function () {
            return this.enableScpLookup;
        },
        set: function (value) {
            this.enableScpLookup = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Calls the redirection URL validation callback.
     *
     * @remark  If the redirection URL validation callback is null, use the default callback which does not allow following any redirections.
     * @param   {string}    redirectionUrl   The redirection URL.
     * @return  {boolean}   True if redirection should be followed.
     */
    AutodiscoverService.prototype.CallRedirectionUrlValidationCallback = function (redirectionUrl) {
        var callback = (this.RedirectionUrlValidationCallback == null)
            ? this.DefaultAutodiscoverRedirectionUrlValidationCallback
            : this.RedirectionUrlValidationCallback;
        return callback(redirectionUrl);
    };
    /**
     * Default implementation of AutodiscoverRedirectionUrlValidationCallback. Always returns true indicating that the URL can be used.
    *
    * @param   {string}     redirectionUrl   The redirection URL.
    * @return  {boolean}    Returns true.
    */
    AutodiscoverService.prototype.DefaultAutodiscoverRedirectionUrlValidationCallback = function (redirectionUrl) {
        throw new AutodiscoverLocalException_1.AutodiscoverLocalException(ExtensionMethods_1.StringHelper.Format("Autodiscover redirection is blocked for url: {0}" /*Strings.AutodiscoverRedirectBlocked*/, redirectionUrl));
    };
    /**
     * Defaults the get autodiscover service urls for domain.
     *
     * @param   {string}    domainName   Name of the domain.
     * @return  {string[]}  [description]
     */
    AutodiscoverService.prototype.DefaultGetScpUrlsForDomain = function (domainName) { return []; }; // System.Collections.Generic.ICollection<string>{ throw new Error("AutodiscoverService.ts - DefaultGetScpUrlsForDomain : Not implemented.");}
    /**
     * Disables SCP lookup if duplicate email address redirection.
     *
     * @param   {string}    emailAddress                The email address to use.
     * @param   {string[]}  redirectionEmailAddresses   The list of prior redirection email addresses.
     */
    AutodiscoverService.prototype.DisableScpLookupIfDuplicateRedirection = function (emailAddress, redirectionEmailAddresses) {
        // SMTP addresses are case-insensitive so entries are converted to lower-case.
        emailAddress = emailAddress.toLowerCase();
        if (redirectionEmailAddresses.includes(emailAddress)) {
            this.EnableScpLookup = false;
        }
        else {
            redirectionEmailAddresses.push(emailAddress);
        }
    };
    /**
     * Gets the autodiscover endpoint URL.
     *
     * @param   {string}   host   The host.
     * @return  {Promise<Uri>}  [description]
     */
    AutodiscoverService.prototype.GetAutodiscoverEndpointUrl = function (host) {
        return __awaiter(this, void 0, Promise_1.Promise, function () {
            var autodiscoverUrlOut;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        autodiscoverUrlOut = { outValue: null };
                        return [4 /*yield*/, this.TryGetAutodiscoverEndpointUrl(host, autodiscoverUrlOut)];
                    case 1:
                        if (_a.sent()) {
                            return [2 /*return*/, autodiscoverUrlOut.outValue];
                        }
                        else {
                            throw new AutodiscoverLocalException_1.AutodiscoverLocalException(Strings_1.Strings.NoSoapOrWsSecurityEndpointAvailable);
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @internal Gets the list of autodiscover service hosts.
     *
     * @param   {string}            domainName     Name of the domain.
     * @param   {IOutParam<number>} scpHostCount   Count of SCP hosts that were found.
     * @return  {string[]}          List of host names.
     */
    AutodiscoverService.prototype.GetAutodiscoverServiceHosts = function (domainName, scpHostCount) {
        var serviceHosts = [];
        var urls = this.GetAutodiscoverServiceUrls(domainName, scpHostCount);
        for (var _i = 0, urls_1 = urls; _i < urls_1.length; _i++) {
            var url = urls_1[_i];
            serviceHosts.push(ExtensionMethods_1.UriHelper.getHost(url));
        }
        return serviceHosts;
    };
    /**
     * @internal Gets the list of autodiscover service URLs.
     *
     * @param   {string}            domainName     Domain name.
     * @param   {IOutParam<number>} scpHostCount   Count of hosts found via SCP lookup.
     * @return  {string[]}          List of Autodiscover URLs.
     */
    AutodiscoverService.prototype.GetAutodiscoverServiceUrls = function (domainName, scpHostCount) {
        var urls = [];
        if (this.EnableScpLookup) {
            // Get SCP URLs
            //Func < string, ICollection <string>> callback = this.GetScpUrlsForDomainCallback ?? this.DefaultGetScpUrlsForDomain;
            //ICollection < string> scpUrls = callback(domainName);
            //foreach(string str in scpUrls)
            //{
            //    urls.Add(new Uri(str));
            //}
        }
        //scpHostCount = urls.length;
        // As a fallback, add autodiscover URLs base on the domain name.
        urls.push(ExtensionMethods_1.StringHelper.Format(AutodiscoverService.AutodiscoverLegacyHttpsUrl, "autodiscover." + domainName)); // hard coding for autodiscover domain name
        urls.push(ExtensionMethods_1.StringHelper.Format(AutodiscoverService.AutodiscoverLegacyHttpsUrl, domainName));
        return urls;
    };
    AutodiscoverService.prototype.GetDomainSettings = function (domainOrDomains, requestedVersion) {
        var settings = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            settings[_i - 2] = arguments[_i];
        }
        return __awaiter(this, void 0, Promise_1.Promise, function () {
            var domains, isCollection, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        isCollection = true;
                        domains = domainOrDomains;
                        if (!Array.isArray(domainOrDomains)) {
                            domains = [domainOrDomains];
                            isCollection = false;
                        }
                        EwsUtilities_1.EwsUtilities.ValidateParam(domains, "domains");
                        EwsUtilities_1.EwsUtilities.ValidateParam(settings, "settings");
                        return [4 /*yield*/, this.GetSettings(domains, settings, requestedVersion, this.InternalGetDomainSettings.bind(this), function () { return domains[0]; })];
                    case 1:
                        result = _a.sent();
                        if (isCollection) {
                            return [2 /*return*/, result];
                        }
                        else {
                            return [2 /*return*/, result.__thisIndexer(0)];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Gets the endpoints from HTTP web response.
     *
     * @param   {XMLHttpRequest}   response   The response.
     * @return  {AutodiscoverEndpoints}              Endpoints enabled.
     */
    AutodiscoverService.prototype.GetEndpointsFromHttpWebResponse = function (response) {
        var endpoints = AutodiscoverEndpoints_1.AutodiscoverEndpoints.Legacy;
        if (!ExtensionMethods_1.StringHelper.IsNullOrEmpty(response.getResponseHeader(AutodiscoverService.AutodiscoverSoapEnabledHeaderName))) {
            endpoints |= AutodiscoverEndpoints_1.AutodiscoverEndpoints.Soap;
        }
        if (!ExtensionMethods_1.StringHelper.IsNullOrEmpty(response.getResponseHeader(AutodiscoverService.AutodiscoverWsSecurityEnabledHeaderName))) {
            endpoints |= AutodiscoverEndpoints_1.AutodiscoverEndpoints.WsSecurity;
        }
        if (!ExtensionMethods_1.StringHelper.IsNullOrEmpty(response.getResponseHeader(AutodiscoverService.AutodiscoverWsSecuritySymmetricKeyEnabledHeaderName))) {
            endpoints |= AutodiscoverEndpoints_1.AutodiscoverEndpoints.WSSecuritySymmetricKey;
        }
        if (!ExtensionMethods_1.StringHelper.IsNullOrEmpty(response.getResponseHeader(AutodiscoverService.AutodiscoverWsSecurityX509CertEnabledHeaderName))) {
            endpoints |= AutodiscoverEndpoints_1.AutodiscoverEndpoints.WSSecurityX509Cert;
        }
        if (!ExtensionMethods_1.StringHelper.IsNullOrEmpty(response.getResponseHeader(AutodiscoverService.AutodiscoverOAuthEnabledHeaderName))) {
            endpoints |= AutodiscoverEndpoints_1.AutodiscoverEndpoints.OAuth;
        }
        return endpoints;
    };
    //GetLegacyUserSettings(emailAddress: string): any{ throw new Error("AutodiscoverService.ts - GetLegacyUserSettings : Not implemented.");}
    //GetLegacyUserSettingsAtUrl(emailAddress: string, url: Uri): any{ throw new Error("AutodiscoverService.ts - GetLegacyUserSettingsAtUrl : Not implemented.");}
    /**
     * @internal Get an autodiscover SRV record in DNS and construct autodiscover URL.
     *
     * @param   {string}   domainName   Name of the domain.
     * @return  {Promise<Uri>}                Autodiscover URL (may be null if lookup failed)
     */
    AutodiscoverService.prototype.GetRedirectionUrlFromDnsSrvRecord = function (domainName) {
        return __awaiter(this, void 0, Promise_1.Promise, function () {
            var hostname;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.TraceMessage(TraceFlags_1.TraceFlags.AutodiscoverConfiguration, ExtensionMethods_1.StringHelper.Format("Trying to get Autodiscover host from DNS SRV record for {0}.", domainName));
                        return [4 /*yield*/, this.dnsClient.FindAutodiscoverHostFromSrv(domainName)];
                    case 1:
                        hostname = _a.sent();
                        if (!ExtensionMethods_1.StringHelper.IsNullOrEmpty(hostname)) {
                            this.TraceMessage(TraceFlags_1.TraceFlags.AutodiscoverConfiguration, ExtensionMethods_1.StringHelper.Format("Autodiscover host {0} was returned.", hostname));
                            return [2 /*return*/, new Uri_1.Uri(ExtensionMethods_1.StringHelper.Format(AutodiscoverService.AutodiscoverLegacyHttpsUrl, hostname))];
                        }
                        else {
                            this.TraceMessage(TraceFlags_1.TraceFlags.AutodiscoverConfiguration, "No matching Autodiscover DNS SRV records were found.");
                            return [2 /*return*/, null];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Gets a redirection URL to an SSL-enabled Autodiscover service from the standard non-SSL Autodiscover URL.
     *
     * @param   {string}   domainName   The name of the domain to call Autodiscover on.
     * @return  {Promise<Uri>}                A valid SSL-enabled redirection URL. (May be null).
     */
    AutodiscoverService.prototype.GetRedirectUrl = function (domainName) {
        return __awaiter(this, void 0, Promise_1.Promise, function () {
            var url, xhrOptions, response, responseError_1, redirectUrl;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = ExtensionMethods_1.StringHelper.Format(AutodiscoverService.AutodiscoverLegacyHttpUrl, "autodiscover." + domainName);
                        this.TraceMessage(TraceFlags_1.TraceFlags.AutodiscoverConfiguration, ExtensionMethods_1.StringHelper.Format("Trying to get Autodiscover redirection URL from {0}.", url));
                        xhrOptions = {
                            type: "GET",
                            url: url,
                            allowRedirect: false,
                        };
                        response = null;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.XHRApi.xhr(xhrOptions)];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        responseError_1 = _a.sent();
                        if (responseError_1.status === 0) {
                            //catch (IOException ex)
                            this.TraceMessage(TraceFlags_1.TraceFlags.AutodiscoverConfiguration, ExtensionMethods_1.StringHelper.Format("I/O error: {0}", "unable to connect"));
                            return [2 /*return*/, null];
                        }
                        this.TraceMessage(TraceFlags_1.TraceFlags.AutodiscoverConfiguration, ExtensionMethods_1.StringHelper.Format("Request error: {0}", responseError_1.message || responseError_1.statusText || responseError_1.status));
                        response = responseError_1;
                        return [3 /*break*/, 4];
                    case 4:
                        if (response != null) {
                            redirectUrl = { outValue: null };
                            if (this.TryGetRedirectionResponse(response, redirectUrl)) {
                                return [2 /*return*/, redirectUrl.outValue];
                            }
                            // hard check for redirected office 365 url
                            this.TraceMessage(TraceFlags_1.TraceFlags.All, "***hard checking for office 365 with node.js http request and presence of header x-federationtrusttokenissueruri= urn:federation:MicrosoftOnline");
                            if (!ExtensionMethods_1.StringHelper.IsNullOrEmpty(response.getResponseHeader(AutodiscoverService.Office365AutodiscoverRedirectHeader))) {
                                if (response.getResponseHeader(AutodiscoverService.Office365AutodiscoverRedirectHeader) === AutodiscoverService.Office365AutodiscoverRedirectHeaderValue)
                                    redirectUrl.outValue = new Uri_1.Uri(AutodiscoverService.Office365AutodiscoverUrl);
                                return [2 /*return*/, redirectUrl.outValue];
                            }
                        }
                        this.TraceMessage(TraceFlags_1.TraceFlags.AutodiscoverConfiguration, "No Autodiscover redirection URL was returned.");
                        return [2 /*return*/, null];
                }
            });
        });
    };
    /**
     * Gets user or domain settings using Autodiscover SOAP service.
     *
     * @typeparam {TGetSettingsResponseCollection}  Type of response collection to return.
     * @typeparam {TSettingName}                    Type of setting name.
     *
     * @param   {string[]}                                                          identities          Either the domains or the SMTP addresses of the users.
     * @param   {settings: TSettingName[]}                                          settings            The settings.
     * @param   {ExchangeVersion}                                                   requestedVersion    Requested version of the Exchange service.
     * @param   {GetSettingsMethod<TGetSettingsResponseCollection, TSettingName>}   getSettingsMethod   The method to use.
     * @param   {() => string}                                                      getDomainMethod     The method to calculate the domain value.
     * @return  {Promise<TGetSettingsResponseCollection>}                           [description]
     */
    AutodiscoverService.prototype.GetSettings = function (identities, settings, requestedVersion, getSettingsMethod, getDomainMethod) {
        return __awaiter(this, void 0, Promise_1.Promise, function () {
            var response, urlRef, autodiscoverUrlRef, autodiscoverUrlOut_1, domainName, scpHostCount, hosts, currentHostIndex, host, isScpHost, error_1, autodiscoverUrl_1, _a, _b, response_1, _c, _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        // Autodiscover service only exists in E14 or later.
                        if (this.RequestedServerVersion < AutodiscoverService.MinimumRequestVersionForAutoDiscoverSoapService) {
                            throw new ServiceVersionException_1.ServiceVersionException(ExtensionMethods_1.StringHelper.Format(Strings_1.Strings.AutodiscoverServiceIncompatibleWithRequestVersion, AutodiscoverService.MinimumRequestVersionForAutoDiscoverSoapService));
                        }
                        response = null;
                        urlRef = null;
                        autodiscoverUrlRef = { getValue: function () { return urlRef; }, setValue: function (url) { return urlRef = url; } };
                        if (!(this.Url != null)) return [3 /*break*/, 2];
                        urlRef = this.url;
                        return [4 /*yield*/, getSettingsMethod(identities, settings, requestedVersion, autodiscoverUrlRef)];
                    case 1:
                        response = _e.sent();
                        this.Url = urlRef;
                        return [2 /*return*/, response];
                    case 2:
                        if (!!ExtensionMethods_1.StringHelper.IsNullOrEmpty(this.Domain)) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.GetAutodiscoverEndpointUrl(this.Domain)];
                    case 3:
                        urlRef = _e.sent();
                        return [4 /*yield*/, getSettingsMethod(identities, settings, requestedVersion, autodiscoverUrlRef)
                            // If we got this far, response was successful, set Url.
                        ];
                    case 4:
                        response = _e.sent();
                        // If we got this far, response was successful, set Url.
                        this.Url = urlRef;
                        return [2 /*return*/, response];
                    case 5:
                        // Assume caller is not inside the Intranet, regardless of whether SCP Urls
                        // were returned or not. SCP Urls are only relevent if one of them returns
                        // valid Autodiscover settings.
                        this.IsExternal = true;
                        autodiscoverUrlOut_1 = { outValue: null };
                        autodiscoverUrlRef = { getValue: function () { return autodiscoverUrlOut_1.outValue; }, setValue: function (url) { autodiscoverUrlOut_1.outValue = url; } };
                        domainName = getDomainMethod();
                        scpHostCount = { outValue: 0 };
                        hosts = this.GetAutodiscoverServiceHosts(domainName, scpHostCount);
                        if (hosts.length == 0) {
                            throw new ServiceValidationException_1.ServiceValidationException(Strings_1.Strings.AutodiscoverServiceRequestRequiresDomainOrUrl);
                        }
                        currentHostIndex = 0;
                        _e.label = 6;
                    case 6:
                        if (!(currentHostIndex < hosts.length)) return [3 /*break*/, 12];
                        host = hosts[currentHostIndex];
                        isScpHost = currentHostIndex < scpHostCount.outValue;
                        return [4 /*yield*/, this.TryGetAutodiscoverEndpointUrl(host, autodiscoverUrlOut_1)];
                    case 7:
                        if (!_e.sent()) return [3 /*break*/, 11];
                        _e.label = 8;
                    case 8:
                        _e.trys.push([8, 10, , 11]);
                        return [4 /*yield*/, getSettingsMethod(identities, settings, requestedVersion, autodiscoverUrlRef)];
                    case 9:
                        response = _e.sent();
                        // If we got this far, the response was successful, set Url.
                        this.Url = autodiscoverUrlOut_1.outValue;
                        // Not external if Autodiscover endpoint found via SCP returned the settings.
                        if (isScpHost) {
                            this.IsExternal = false;
                        }
                        return [2 /*return*/, response];
                    case 10:
                        error_1 = _e.sent();
                        return [3 /*break*/, 11];
                    case 11:
                        currentHostIndex++;
                        return [3 /*break*/, 6];
                    case 12:
                        this.TraceMessage(TraceFlags_1.TraceFlags.DebugMessage, "[Next-to-last chance: for autodiscover redirect] --hard checking for office 365 with node.js http request and presence of header x-federationtrusttokenissueruri: urn:federation:MicrosoftOnline. All other redirection wil fail");
                        autodiscoverUrl_1 = { outValue: null };
                        _a = autodiscoverUrl_1;
                        return [4 /*yield*/, this.GetRedirectUrl(domainName)];
                    case 13:
                        _a.outValue = _e.sent();
                        autodiscoverUrlRef = { getValue: function () { return autodiscoverUrl_1.outValue; }, setValue: function (url) { autodiscoverUrl_1.outValue = url; } };
                        _b = (autodiscoverUrl_1.outValue != null) &&
                            this.CallRedirectionUrlValidationCallback(autodiscoverUrl_1.outValue.ToString());
                        if (!_b) return [3 /*break*/, 15];
                        return [4 /*yield*/, this.TryGetAutodiscoverEndpointUrl(autodiscoverUrl_1.outValue.Host, autodiscoverUrl_1)];
                    case 14:
                        _b = (_e.sent());
                        _e.label = 15;
                    case 15:
                        if (!_b) return [3 /*break*/, 17];
                        return [4 /*yield*/, getSettingsMethod(identities, settings, requestedVersion, { getValue: function () { return autodiscoverUrl_1.outValue; } })
                            // If we got this far, response was successful, set Url.
                        ];
                    case 16:
                        response_1 = _e.sent();
                        // If we got this far, response was successful, set Url.
                        this.Url = autodiscoverUrl_1.outValue;
                        return [2 /*return*/, response_1];
                    case 17:
                        // Last Chance: try to read autodiscover SRV Record from DNS. If we find one, use
                        // the hostname returned to construct an Autodiscover endpoint URL.
                        _c = autodiscoverUrl_1;
                        return [4 /*yield*/, this.GetRedirectionUrlFromDnsSrvRecord(domainName)];
                    case 18:
                        // Last Chance: try to read autodiscover SRV Record from DNS. If we find one, use
                        // the hostname returned to construct an Autodiscover endpoint URL.
                        _c.outValue = _e.sent();
                        _d = (autodiscoverUrl_1.outValue != null) &&
                            this.CallRedirectionUrlValidationCallback(autodiscoverUrl_1.outValue.ToString());
                        if (!_d) return [3 /*break*/, 20];
                        return [4 /*yield*/, this.TryGetAutodiscoverEndpointUrl(autodiscoverUrl_1.outValue.Host, autodiscoverUrl_1)];
                    case 19:
                        _d = (_e.sent());
                        _e.label = 20;
                    case 20:
                        if (!_d) return [3 /*break*/, 22];
                        return [4 /*yield*/, getSettingsMethod(identities, settings, requestedVersion, autodiscoverUrlRef)];
                    case 21:
                        response = _e.sent();
                        // If we got this far, the response was successful, set Url.
                        this.Url = autodiscoverUrl_1.outValue;
                        return [2 /*return*/, response];
                    case 22: 
                    // else block not needed, if we get this far that mean no autodiscover url can be located
                    throw new AutodiscoverLocalException_1.AutodiscoverLocalException(Strings_1.Strings.AutodiscoverCouldNotBeLocated);
                }
            });
        });
    };
    AutodiscoverService.prototype.GetUserSettings = function (smtpAddresses, userSettings) {
        return __awaiter(this, void 0, Promise_1.Promise, function () {
            var userSmtpAddress, requestedSettings;
            return __generator(this, function (_a) {
                if (ExtensionMethods_1.isNullOrUndefined(userSettings) || ExtensionMethods_1.isNullOrUndefined(userSettings)) {
                    throw new ArgumentException_1.ArgumentException("AutodiscoverService.ts - GetUserSettings - Required parameters missing");
                }
                if (Array.isArray(smtpAddresses)) {
                    EwsUtilities_1.EwsUtilities.ValidateParam(smtpAddresses, "smtpAddresses");
                    EwsUtilities_1.EwsUtilities.ValidateParam(userSettings, "settings");
                    return [2 /*return*/, this.GetSettings(smtpAddresses, userSettings, null, this.InternalGetUserSettings.bind(this), function () { return EwsUtilities_1.EwsUtilities.DomainFromEmailAddress(smtpAddresses[0]); })];
                }
                userSmtpAddress = smtpAddresses;
                if (ExtensionMethods_1.StringHelper.IsNullOrEmpty(userSmtpAddress)) {
                    throw new ServiceValidationException_1.ServiceValidationException(Strings_1.Strings.InvalidAutodiscoverSmtpAddress);
                }
                requestedSettings = userSettings || [];
                if (requestedSettings.length == 0) {
                    throw new ServiceValidationException_1.ServiceValidationException(Strings_1.Strings.InvalidAutodiscoverSettingsCount);
                }
                if (this.RequestedServerVersion < AutodiscoverService.MinimumRequestVersionForAutoDiscoverSoapService) {
                    return [2 /*return*/, this.InternalGetLegacyUserSettings(userSmtpAddress, requestedSettings)];
                }
                else {
                    return [2 /*return*/, this.InternalGetSoapUserSettings(userSmtpAddress, requestedSettings)];
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Retrieves the specified settings for a set of users.
     *
     * @param   {string[]}              userSmtpAddresses   The SMTP addresses of the users.
     * @param   {...UserSettingName[]}  userSettingNames    The user setting names.
     * @return  {Promise<GetUserSettingsResponseCollection>}    A GetUserSettingsResponseCollection object containing the responses for each individual user.
     */
    AutodiscoverService.prototype.GetUsersSettings = function (userSmtpAddresses) {
        var userSettingNames = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            userSettingNames[_i - 1] = arguments[_i];
        }
        return __awaiter(this, void 0, Promise_1.Promise, function () {
            return __generator(this, function (_a) {
                if (this.RequestedServerVersion < AutodiscoverService.MinimumRequestVersionForAutoDiscoverSoapService) {
                    throw new ServiceVersionException_1.ServiceVersionException(ExtensionMethods_1.StringHelper.Format(Strings_1.Strings.AutodiscoverServiceIncompatibleWithRequestVersion, AutodiscoverService.MinimumRequestVersionForAutoDiscoverSoapService));
                }
                return [2 /*return*/, this.GetUserSettings(userSmtpAddresses, userSettingNames)]; //calls getsettings
            });
        });
    };
    /**
     * Gets settings for one or more domains.
     *
     * @param   {string[]}              domains            The domains.
     * @param   {DomainSettingName[]}   settings           The settings.
     * @param   {ExchangeVersion}       requestedVersion   Requested version of the Exchange service.
     * @param   {IRefParam<Uri>}        autodiscoverUrl    The autodiscover URL.
     * @return  {AutodiscoverService}   GetDomainSettingsResponse collection.
     */
    AutodiscoverService.prototype.InternalGetDomainSettings = function (domains, settings, requestedVersion, autodiscoverUrlRef) {
        return __awaiter(this, void 0, Promise_1.Promise, function () {
            var currentHop, request, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        currentHop = 0;
                        _a.label = 1;
                    case 1:
                        if (!(currentHop < AutodiscoverService.AutodiscoverMaxRedirections)) return [3 /*break*/, 4];
                        request = new GetDomainSettingsRequest_1.GetDomainSettingsRequest(this, autodiscoverUrlRef.getValue());
                        request.Domains = domains;
                        request.Settings = settings;
                        request.RequestedVersion = requestedVersion;
                        return [4 /*yield*/, request.Execute()];
                    case 2:
                        response = _a.sent();
                        // Did we get redirected?
                        if (response.ErrorCode == AutodiscoverErrorCode_1.AutodiscoverErrorCode.RedirectUrl && response.RedirectionUrl != null) {
                            autodiscoverUrlRef.setValue(response.RedirectionUrl);
                        }
                        else {
                            return [2 /*return*/, response];
                        }
                        _a.label = 3;
                    case 3:
                        currentHop++;
                        return [3 /*break*/, 1];
                    case 4:
                        this.TraceMessage(TraceFlags_1.TraceFlags.AutodiscoverConfiguration, ExtensionMethods_1.StringHelper.Format("Maximum number of redirection hops {0} exceeded", AutodiscoverService.AutodiscoverMaxRedirections));
                        throw new AutodiscoverLocalException_1.AutodiscoverLocalException(Strings_1.Strings.MaximumRedirectionHopsExceeded);
                }
            });
        });
    };
    AutodiscoverService.prototype.InternalGetLegacyUserSettings = function (emailAddress, requestedSettings) {
        return __awaiter(this, void 0, Promise_1.Promise, function () {
            return __generator(this, function (_a) {
                throw new Error("Not implemented.");
            });
        });
    };
    AutodiscoverService.prototype.InternalGetLegacyUserSettingsPrivate = function (emailAddress, redirectionEmailAddresses, currentHop) {
        throw new Error("Not implemented.");
    };
    /**
     * @internal Calls the SOAP Autodiscover service for user settings for a single SMTP address.
     *
     * @param   {string}            smtpAddress         SMTP address.
     * @param   {UserSettingName[]} requestedSettings   The requested settings.
     * @return  {Promise<GetUserSettingsResponse>}                       [description]
     */
    AutodiscoverService.prototype.InternalGetSoapUserSettings = function (smtpAddress, requestedSettings) {
        return __awaiter(this, void 0, Promise_1.Promise, function () {
            var smtpAddresses, redirectionEmailAddresses, currentHop, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        smtpAddresses = [smtpAddress];
                        redirectionEmailAddresses = [smtpAddress.toLowerCase()];
                        currentHop = 0;
                        _a.label = 1;
                    case 1:
                        if (!(currentHop < AutodiscoverService.AutodiscoverMaxRedirections)) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.GetUserSettings(smtpAddresses, requestedSettings)];
                    case 2:
                        response = (_a.sent()).Responses[0];
                        // const responses: GetUserSettingsResponseCollection = await this.GetUserSettings(smtpAddresses, requestedSettings);
                        // const response: GetUserSettingsResponse =responses[0];
                        switch (response.ErrorCode) {
                            case AutodiscoverErrorCode_1.AutodiscoverErrorCode.RedirectAddress:
                                this.TraceMessage(TraceFlags_1.TraceFlags.AutodiscoverResponse, ExtensionMethods_1.StringHelper.Format("Autodiscover service returned redirection email address '{0}'.", response.RedirectTarget));
                                smtpAddresses.splice(0);
                                smtpAddresses.push(response.RedirectTarget.toLowerCase());
                                this.Url = null;
                                this.Domain = null;
                                // If this email address was already tried, we may have a loop
                                // in SCP lookups. Disable consideration of SCP records.
                                this.ThrowIfDuplicateRedirection(response.RedirectTarget, { getValue: function () { return redirectionEmailAddresses; } });
                                break;
                            case AutodiscoverErrorCode_1.AutodiscoverErrorCode.RedirectUrl:
                                this.TraceMessage(TraceFlags_1.TraceFlags.AutodiscoverResponse, ExtensionMethods_1.StringHelper.Format("Autodiscover service returned redirection URL '{0}'.", response.RedirectTarget));
                                this.Url = this.Credentials.AdjustUrl(new Uri_1.Uri(response.RedirectTarget));
                                break;
                            case AutodiscoverErrorCode_1.AutodiscoverErrorCode.NoError:
                            default:
                                return [2 /*return*/, response];
                        }
                        _a.label = 3;
                    case 3:
                        currentHop++;
                        return [3 /*break*/, 1];
                    case 4: throw new AutodiscoverLocalException_1.AutodiscoverLocalException(Strings_1.Strings.AutodiscoverCouldNotBeLocated);
                }
            });
        });
    };
    /**
     * Gets settings for one or more users.
     *
     * @param   {string[]}            smtpAddresses      The SMTP addresses of the users.
     * @param   {UserSettingName[]}   settings           The settings.
     * @param   {ExchangeVersion}     requestedVersion   Requested version of the Exchange service.
     * @param   {IRefParam<Uri>}      autodiscoverUrl    The autodiscover URL.
     * @return  {Promise<GetUserSettingsResponseCollection>}                      GetUserSettingsResponse collection.
     */
    AutodiscoverService.prototype.InternalGetUserSettings = function (smtpAddresses, settings, requestedVersion, autodiscoverUrlRef) {
        return __awaiter(this, void 0, Promise_1.Promise, function () {
            var currentHop, request, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        currentHop = 0;
                        _a.label = 1;
                    case 1:
                        if (!(currentHop < AutodiscoverService.AutodiscoverMaxRedirections)) return [3 /*break*/, 4];
                        request = new GetUserSettingsRequest_1.GetUserSettingsRequest(this, autodiscoverUrlRef.getValue());
                        request.SmtpAddresses = smtpAddresses;
                        request.Settings = settings;
                        return [4 /*yield*/, request.Execute()];
                    case 2:
                        response = _a.sent();
                        // Did we get redirected?
                        if (response.ErrorCode == AutodiscoverErrorCode_1.AutodiscoverErrorCode.RedirectUrl && response.RedirectionUrl != null) {
                            this.TraceMessage(TraceFlags_1.TraceFlags.AutodiscoverConfiguration, ExtensionMethods_1.StringHelper.Format("Request to {0} returned redirection to {1}", autodiscoverUrlRef.getValue().ToString(), response.RedirectionUrl.ToString()));
                            // this url need be brought back to the caller.
                            //
                            autodiscoverUrlRef.setValue(response.RedirectionUrl);
                        }
                        else {
                            return [2 /*return*/, response];
                        }
                        _a.label = 3;
                    case 3:
                        currentHop++;
                        return [3 /*break*/, 1];
                    case 4:
                        this.TraceMessage(TraceFlags_1.TraceFlags.AutodiscoverConfiguration, ExtensionMethods_1.StringHelper.Format("Maximum number of redirection hops {0} exceeded", AutodiscoverService.AutodiscoverMaxRedirections));
                        throw new AutodiscoverLocalException_1.AutodiscoverLocalException(Strings_1.Strings.AutodiscoverCouldNotBeLocated);
                }
            });
        });
    };
    //PrepareHttpWebRequestForUrl(url: Uri): Data.IEwsHttpWebRequest{ throw new Error("AutodiscoverService.ts - PrepareHttpWebRequestForUrl : Not implemented.");}
    //ProcessHttpErrorResponse(httpWebResponse: Data.IEwsHttpWebResponse, webException: any): any{ throw new Error("AutodiscoverService.ts - ProcessHttpErrorResponse : Not implemented.");}
    AutodiscoverService.prototype.ProcessHttpErrorResponse = function (httpWebResponse, webException) { /*throw new Error("Not implemented.")*/ ; };
    AutodiscoverService.prototype.TraceResponse = function (response, memoryStream) {
        //todo: implement tracing
        //this.ProcessHttpResponseHeaders(TraceFlags.AutodiscoverResponseHttpHeaders, response);
        //if (this.TraceEnabled) {
        //    if (!StringHelper.IsNullOrEmpty(response.ContentType) &&
        //        (response.ContentType.StartsWith("text/", StringComparison.OrdinalIgnoreCase) ||
        //        response.ContentType.StartsWith("application/soap", StringComparison.OrdinalIgnoreCase))) {
        //        this.TraceXml(TraceFlags.AutodiscoverResponse, memoryStream);
        //    }
        //    else {
        //        this.TraceMessage(TraceFlags.AutodiscoverResponse, "Non-textual response");
        //    }
        //}
    };
    /**
     * Tries the get Autodiscover Service endpoint URL.
     *
     * @param   {string}          host   The host.
     * @param   {IOutParam<Uri>}  url    The URL.
     * @return  {Promise<boolean>}         [description]
     */
    AutodiscoverService.prototype.TryGetAutodiscoverEndpointUrl = function (hostref, url) {
        return __awaiter(this, void 0, Promise_1.Promise, function () {
            var endpointsOut, host, hostRefParam, endpoints;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url.outValue = null;
                        endpointsOut = { outValue: AutodiscoverEndpoints_1.AutodiscoverEndpoints.None };
                        host = hostref;
                        hostRefParam = { getValue: function () { return host; }, setValue: function (value) { host = value; } };
                        return [4 /*yield*/, this.TryGetEnabledEndpointsForHost(hostRefParam, endpointsOut)];
                    case 1:
                        if (_a.sent()) {
                            // host = hostref;
                            url.outValue = new Uri_1.Uri(ExtensionMethods_1.StringHelper.Format(AutodiscoverService.AutodiscoverSoapHttpsUrl, host));
                            endpoints = endpointsOut.outValue;
                            // Make sure that at least one of the non-legacy endpoints is available.
                            if (((endpoints & AutodiscoverEndpoints_1.AutodiscoverEndpoints.Soap) != AutodiscoverEndpoints_1.AutodiscoverEndpoints.Soap) &&
                                ((endpoints & AutodiscoverEndpoints_1.AutodiscoverEndpoints.WsSecurity) != AutodiscoverEndpoints_1.AutodiscoverEndpoints.WsSecurity) &&
                                ((endpoints & AutodiscoverEndpoints_1.AutodiscoverEndpoints.WSSecuritySymmetricKey) != AutodiscoverEndpoints_1.AutodiscoverEndpoints.WSSecuritySymmetricKey) &&
                                ((endpoints & AutodiscoverEndpoints_1.AutodiscoverEndpoints.WSSecurityX509Cert) != AutodiscoverEndpoints_1.AutodiscoverEndpoints.WSSecurityX509Cert) &&
                                ((endpoints & AutodiscoverEndpoints_1.AutodiscoverEndpoints.OAuth) != AutodiscoverEndpoints_1.AutodiscoverEndpoints.OAuth)) {
                                this.TraceMessage(TraceFlags_1.TraceFlags.AutodiscoverConfiguration, ExtensionMethods_1.StringHelper.Format("No Autodiscover endpoints are available  for host {0}", host));
                                return [2 /*return*/, false];
                            }
                            // If we have WLID credentials, make sure that we have a WS-Security endpoint
                            if (this.Credentials instanceof WindowsLiveCredentials_1.WindowsLiveCredentials) {
                                if ((endpoints & AutodiscoverEndpoints_1.AutodiscoverEndpoints.WsSecurity) != AutodiscoverEndpoints_1.AutodiscoverEndpoints.WsSecurity) {
                                    this.TraceMessage(TraceFlags_1.TraceFlags.AutodiscoverConfiguration, ExtensionMethods_1.StringHelper.Format("No Autodiscover WS-Security endpoint is available for host {0}", host));
                                    return [2 /*return*/, false];
                                }
                                else {
                                    url.outValue = new Uri_1.Uri(ExtensionMethods_1.StringHelper.Format(AutodiscoverService.AutodiscoverSoapWsSecurityHttpsUrl, host));
                                }
                            }
                            else if (this.Credentials instanceof PartnerTokenCredentials_1.PartnerTokenCredentials) {
                                if ((endpoints & AutodiscoverEndpoints_1.AutodiscoverEndpoints.WSSecuritySymmetricKey) != AutodiscoverEndpoints_1.AutodiscoverEndpoints.WSSecuritySymmetricKey) {
                                    this.TraceMessage(TraceFlags_1.TraceFlags.AutodiscoverConfiguration, ExtensionMethods_1.StringHelper.Format("No Autodiscover WS-Security/SymmetricKey endpoint is available for host {0}", host));
                                    return [2 /*return*/, false];
                                }
                                else {
                                    url.outValue = new Uri_1.Uri(ExtensionMethods_1.StringHelper.Format(AutodiscoverService.AutodiscoverSoapWsSecuritySymmetricKeyHttpsUrl, host));
                                }
                            }
                            else if (this.Credentials instanceof X509CertificateCredentials_1.X509CertificateCredentials) {
                                if ((endpoints & AutodiscoverEndpoints_1.AutodiscoverEndpoints.WSSecurityX509Cert) != AutodiscoverEndpoints_1.AutodiscoverEndpoints.WSSecurityX509Cert) {
                                    this.TraceMessage(TraceFlags_1.TraceFlags.AutodiscoverConfiguration, ExtensionMethods_1.StringHelper.Format("No Autodiscover WS-Security/X509Cert endpoint is available for host {0}", host));
                                    return [2 /*return*/, false];
                                }
                                else {
                                    url.outValue = new Uri_1.Uri(ExtensionMethods_1.StringHelper.Format(AutodiscoverService.AutodiscoverSoapWsSecurityX509CertHttpsUrl, host));
                                }
                            }
                            else if (this.Credentials instanceof OAuthCredentials_1.OAuthCredentials) {
                                // If the credential is OAuthCredentials, no matter whether we have
                                // the corresponding x-header, we will go with OAuth.
                                url.outValue = new Uri_1.Uri(ExtensionMethods_1.StringHelper.Format(AutodiscoverService.AutodiscoverSoapHttpsUrl, host));
                            }
                            return [2 /*return*/, true];
                        }
                        else {
                            this.TraceMessage(TraceFlags_1.TraceFlags.AutodiscoverConfiguration, ExtensionMethods_1.StringHelper.Format("No Autodiscover endpoints are available for host {0}", host));
                            return [2 /*return*/, false];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Gets the enabled autodiscover endpoints on a specific host.
     *
     * @param   {host: IRefParam<string>}   host        The host.
     * @param   {IOutParam<AutodiscoverEndpoints>}   endpoints   Endpoints found for host.
     */
    AutodiscoverService.prototype.TryGetEnabledEndpointsForHost = function (host, endpoints) {
        return __awaiter(this, void 0, Promise_1.Promise, function () {
            var currentHop, autoDiscoverUrl, xhrOptions, response, responseError_2, redirectUrl;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.TraceMessage(TraceFlags_1.TraceFlags.AutodiscoverConfiguration, ExtensionMethods_1.StringHelper.Format("Determining which endpoints are enabled for host {0}", host.getValue()));
                        currentHop = 0;
                        _a.label = 1;
                    case 1:
                        if (!(currentHop < AutodiscoverService.AutodiscoverMaxRedirections)) return [3 /*break*/, 7];
                        autoDiscoverUrl = ExtensionMethods_1.StringHelper.Format(AutodiscoverService.AutodiscoverLegacyHttpsUrl, host.getValue());
                        endpoints.outValue = AutodiscoverEndpoints_1.AutodiscoverEndpoints.None;
                        xhrOptions = {
                            type: "GET",
                            url: autoDiscoverUrl,
                            allowRedirect: false,
                        };
                        response = null;
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, this.XHRApi.xhr(xhrOptions)];
                    case 3:
                        // try get response, in most cases this will not be a status 200.
                        response = _a.sent();
                        return [3 /*break*/, 5];
                    case 4:
                        responseError_2 = _a.sent();
                        if (responseError_2.status === 0) {
                            //catch (IOException ex) and return false
                            this.TraceMessage(TraceFlags_1.TraceFlags.AutodiscoverConfiguration, ExtensionMethods_1.StringHelper.Format("I/O error: {0}", "unable to connect"));
                            return [2 /*return*/, false];
                        }
                        this.TraceMessage(TraceFlags_1.TraceFlags.AutodiscoverConfiguration, ExtensionMethods_1.StringHelper.Format("Request error: {0}", responseError_2.message || responseError_2.statusText || responseError_2.status));
                        // assign error to response
                        response = responseError_2;
                        return [3 /*break*/, 5];
                    case 5:
                        if (response != null) {
                            redirectUrl = { outValue: null };
                            if (this.TryGetRedirectionResponse(response, redirectUrl)) {
                                this.TraceMessage(TraceFlags_1.TraceFlags.AutodiscoverConfiguration, ExtensionMethods_1.StringHelper.Format("Host returned redirection to host '{0}'", redirectUrl.outValue.Host));
                                host.setValue(redirectUrl.outValue.Host);
                            }
                            else {
                                endpoints.outValue = this.GetEndpointsFromHttpWebResponse(response);
                                this.TraceMessage(TraceFlags_1.TraceFlags.AutodiscoverConfiguration, ExtensionMethods_1.StringHelper.Format("Host returned enabled endpoint flags: {0}", ExtensionMethods_1.EnumHelper.ToString(AutodiscoverEndpoints_1.AutodiscoverEndpoints, endpoints.outValue)));
                                return [2 /*return*/, true];
                                // hold it for bug reports, if not delete after few version later (0.10)
                                // if (resperr.status === 401) {
                                //   endpoints.outValue = this.GetEndpointsFromHttpWebResponse(resperr);
                                //   this.TraceMessage(
                                //     TraceFlags.AutodiscoverConfiguration,
                                //     StringHelper.Format("Host returned enabled endpoint flags: {0}", EnumHelper.ToString(AutodiscoverEndpoints, endpoints.outValue)));
                                //   return true;
                                // } else {
                                //   //catch (WebException ex)
                                //   this.TraceMessage(
                                //     TraceFlags.AutodiscoverConfiguration,
                                //     StringHelper.Format("Request error: {0}, {1}", resperr.status, resperr.statusText));
                                // }
                                // return false;
                            }
                        }
                        else {
                            return [2 /*return*/, false];
                        }
                        _a.label = 6;
                    case 6:
                        currentHop++;
                        return [3 /*break*/, 1];
                    case 7:
                        this.TraceMessage(TraceFlags_1.TraceFlags.AutodiscoverConfiguration, ExtensionMethods_1.StringHelper.Format("Maximum number of redirection hops {0} exceeded", AutodiscoverService.AutodiscoverMaxRedirections));
                        throw new AutodiscoverLocalException_1.AutodiscoverLocalException(Strings_1.Strings.MaximumRedirectionHopsExceeded);
                }
            });
        });
    };
    AutodiscoverService.prototype.ThrowIfDuplicateRedirection = function (emailAddress, redirectionEmailAddresses) {
        // SMTP addresses are case-insensitive so entries are converted to lower-case.
        emailAddress = emailAddress.toLowerCase();
        if (redirectionEmailAddresses.getValue().includes(emailAddress)) {
            //this.EnableScpLookup = false;
            throw new AutodiscoverLocalException_1.AutodiscoverLocalException("Detected redirection loop, Redirection address already tried");
        }
        else {
            var oldcount = redirectionEmailAddresses.getValue().length;
            redirectionEmailAddresses.getValue().push(emailAddress);
            if (oldcount === redirectionEmailAddresses.getValue().length) {
                throw new Error("AutodiscoverService.ts - error in ref param logic, need to fix array type getter");
            }
            EwsLogging_1.EwsLogging.Assert(false, "AutodiscoverService.ts - ThrowIfDuplicateRedirection", "AutodiscoverService.ts - array getter worked:), remove this message and throw statement");
        }
    };
    //TryGetPartnerAccess(targetTenantDomain: string, partnerAccessCredentials: any, targetTenantAutodiscoverUrl: any): boolean{ throw new Error("AutodiscoverService.ts - TryGetPartnerAccess : Not implemented.");}
    /**
     * Tries the get redirection response.
     *
     * @param   {XMLHttpRequest}  response      The response.
     * @param   {IOutParam<Uri>}  redirectUrl   The redirect URL.
     * @return  {boolean}         True if a valid redirection URL was found.
     */
    AutodiscoverService.prototype.TryGetRedirectionResponse = function (response, redirectUrl) {
        redirectUrl.outValue = null;
        if (AutodiscoverRequest_1.AutodiscoverRequest.IsRedirectionResponse(response)) {
            // Get the redirect location and verify that it's valid.
            var location_1 = response.getResponseHeader("Location"); // HttpResponseHeader.Location
            if (!ExtensionMethods_1.StringHelper.IsNullOrEmpty(location_1)) {
                try {
                    redirectUrl.outValue = new Uri_1.Uri(location_1);
                    // Check if URL is SSL and that the path matches.
                    var match = AutodiscoverService.LegacyPathRegex.test(redirectUrl.outValue.AbsoluteUri);
                    if ((redirectUrl.outValue.Scheme == Uri_1.Uri.UriSchemeHttps) &&
                        match) {
                        this.TraceMessage(TraceFlags_1.TraceFlags.AutodiscoverConfiguration, ExtensionMethods_1.StringHelper.Format("Redirection URL found: '{0}'", redirectUrl.outValue));
                        return true;
                    }
                }
                catch (UriFormatException) {
                    this.TraceMessage(TraceFlags_1.TraceFlags.AutodiscoverConfiguration, ExtensionMethods_1.StringHelper.Format("Invalid redirection URL was returned: '{0}'", location_1));
                    return false;
                }
            }
        }
        return false;
    };
    //#region Static members
    /**
     * Autodiscover legacy path
     *
     * @static
     */
    AutodiscoverService.AutodiscoverLegacyPath = "/autodiscover/autodiscover.xml";
    /**
     * Autodiscover legacy Url with protocol fill-in
     *
     * @static
     */
    AutodiscoverService.AutodiscoverLegacyUrl = "{0}://{1}" + AutodiscoverService.AutodiscoverLegacyPath;
    /**
     * Autodiscover legacy HTTPS Url
     *
     * @static
     */
    AutodiscoverService.AutodiscoverLegacyHttpsUrl = "https://{0}" + AutodiscoverService.AutodiscoverLegacyPath;
    /**
     * Autodiscover legacy HTTP Url
     *
     * @static
     */
    AutodiscoverService.AutodiscoverLegacyHttpUrl = "http://{0}" + AutodiscoverService.AutodiscoverLegacyPath;
    /**
     * Autodiscover SOAP HTTPS Url
     *
     * @static
     */
    AutodiscoverService.AutodiscoverSoapHttpsUrl = "https://{0}/autodiscover/autodiscover.svc";
    /**
     * Autodiscover SOAP WS-Security HTTPS Url
     *
     * @static
     */
    AutodiscoverService.AutodiscoverSoapWsSecurityHttpsUrl = AutodiscoverService.AutodiscoverSoapHttpsUrl + "/wssecurity";
    /**
     * Autodiscover SOAP WS-Security symmetrickey HTTPS Url
     *
     * @static
     */
    AutodiscoverService.AutodiscoverSoapWsSecuritySymmetricKeyHttpsUrl = AutodiscoverService.AutodiscoverSoapHttpsUrl + "/wssecurity/symmetrickey";
    /**
     * Autodiscover SOAP WS-Security x509cert HTTPS Url
     *
     * @static
     */
    AutodiscoverService.AutodiscoverSoapWsSecurityX509CertHttpsUrl = AutodiscoverService.AutodiscoverSoapHttpsUrl + "/wssecurity/x509cert";
    /**
     * Autodiscover request namespace
     *
     * @static
     */
    AutodiscoverService.AutodiscoverRequestNamespace = "http://schemas.microsoft.com/exchange/autodiscover/outlook/requestschema/2006";
    /**
     * Legacy path regular expression.
     *
     * @static
     */
    AutodiscoverService.LegacyPathRegex = new RegExp("\/autodiscover/([^/]+/)*autodiscover.xml");
    /**
     * Maximum number of Url (or address) redirections that will be followed by an Autodiscover call
     *
     * @static
     */
    AutodiscoverService.AutodiscoverMaxRedirections = 10;
    /**
     * HTTP header indicating that SOAP Autodiscover service is enabled.
     *
     * @static
     */
    AutodiscoverService.AutodiscoverSoapEnabledHeaderName = "X-SOAP-Enabled";
    /**
     * HTTP header indicating that WS-Security Autodiscover service is enabled.
     *
     * @static
     */
    AutodiscoverService.AutodiscoverWsSecurityEnabledHeaderName = "X-WSSecurity-Enabled";
    /**
     * HTTP header indicating that WS-Security/SymmetricKey Autodiscover service is enabled.
     *
     * @static
     */
    AutodiscoverService.AutodiscoverWsSecuritySymmetricKeyEnabledHeaderName = "X-WSSecurity-SymmetricKey-Enabled";
    /**
     * HTTP header indicating that WS-Security/X509Cert Autodiscover service is enabled.
     *
     * @static
     */
    AutodiscoverService.AutodiscoverWsSecurityX509CertEnabledHeaderName = "X-WSSecurity-X509Cert-Enabled";
    /**
     * HTTP header indicating that OAuth Autodiscover service is enabled.
     *
     * @static
     */
    AutodiscoverService.AutodiscoverOAuthEnabledHeaderName = "X-OAuth-Enabled";
    /**
     * Minimum request version for Autodiscover SOAP service.
     *
     * @static
     */
    AutodiscoverService.MinimumRequestVersionForAutoDiscoverSoapService = ExchangeVersion_1.ExchangeVersion.Exchange2010;
    //#endregion
    //#region static method for setting Office 365 specific autodiscover URl, can be used in O365 in China and govt community cloud
    AutodiscoverService.o365AutodiscoverUrl = "https://autodiscover-s.outlook.com/autodiscover/autodiscover.svc";
    AutodiscoverService.o365AutodiscoverRedirectHeader = "x-federationtrusttokenissueruri";
    AutodiscoverService.o365AutodiscoverRedirectHeaderValue = "urn:federation:MicrosoftOnline";
    return AutodiscoverService;
}(ExchangeServiceBase_1.ExchangeServiceBase));
exports.AutodiscoverService = AutodiscoverService;
//class GetSettingsMethod<TGetSettingsResponseCollection, TSettingName> extends System.MulticastDelegate {
//    BeginInvoke(smtpAddresses: System.Collections.Generic.List<string>, settings: System.Collections.Generic.List<T>, requestedVersion: Data.ExchangeVersion, autodiscoverUrl: any, callback: System.AsyncCallback, object: any): System.IAsyncResult { throw new Error("AutodiscoverService.ts - BeginInvoke : Not implemented."); }
//    EndInvoke(autodiscoverUrl: any, result: System.IAsyncResult): TGetSettingsResponseCollection { throw new Error("AutodiscoverService.ts - EndInvoke : Not implemented."); }
//    Invoke(smtpAddresses: System.Collections.Generic.List<string>, settings: System.Collections.Generic.List<T>, requestedVersion: Data.ExchangeVersion, autodiscoverUrl: any): TGetSettingsResponseCollection { throw new Error("AutodiscoverService.ts - Invoke : Not implemented."); }
//}
// delete - function getAutodiscoverConstructorSuperParameters(
//     domainUrlServiceOrVersion: string | Uri | ExchangeServiceBase | ExchangeVersion = null,
//     domainOrVersion: string | ExchangeVersion = null,
//     version: ExchangeVersion = ExchangeVersion.Exchange2010
// ) {
//     const service: ExchangeServiceBase = domainUrlServiceOrVersion instanceof ExchangeServiceBase ? domainUrlServiceOrVersion : null;
//     let serviceVersion: ExchangeVersion = version;
//     if(service) {
//         serviceVersion = service.RequestedServerVersion;
//     }
//     if(typeof domainOrVersion === 'number') {
//         serviceVersion = domainOrVersion;
//     }
//     return { service, version };
// }
//# sourceMappingURL=AutodiscoverService.js.map